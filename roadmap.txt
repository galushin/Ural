/**
Ближайшие цели (0.1):

+ Аналоги средства из <numeric> стандартной библиотеки С++

* Аналоги средства из <functional> стандартной библиотеки С++: divides,
greater_equal, less_equal, bit_and, bit_or, bit_xor, bit_not, специализации для
указателей

* Аналоги средства из <iterator> стандартной библиотеки С++
* Аналоги средства из <algorithm> стандартной библиотеки С++, за исключением
алгоритмов, связанных со случайными числами

* возвращаемое значение rotate(s1, s2) и inplace_stable_partition
--------------------------------------------------------------------------------
1.0

[2014-03-03-14.19] Дискретное распределение по Уолкеру

* Разобраться с иерархией категорий последовательностей. В частности, от чего
должен наследовать random_access_traversal_tag
* аналоги возможностей <algorithm>: shuffle и random_shuffle
* Определить, должен ли SinglePassSequence быть EqualityComparable
* Полная документация
--------------------------------------------------------------------------------
Дальнейшие цели:

+ Распаковка кортежа в список аргументов функции

* универсальный интерфейс для tuple, pair, complex, compressed_pair

* Класс многочлена (на основе вектора)
* Класс многочлена (на основе связного списка)
* Интерполяционные многочлены (Ньютона и Лагранжа)
* Алгоритм ортогононализации
* Ортогональные многочлены

* усилить категорию обхода последовательностей, когда это возможно
* аналог boost::operators с поддержкой constexpr
* минимизировать число явных циклов
* создание контейнеров на основе последовательности
* Аналоги remove и remove_if, если копирующие версии имеют большую сложность,
чем версии, работающие на месте.
* Сопостовимое быстродействие со стандартной библиотекой (в частности, за счёт
специализированных алгоритмов copy).
* Оптимизация inplace_merge, equal_range, nth_element, rotate(s1, s2),
partition, stable_partition
* Поддержка разных компиляторов (Clang, VS)
* минимизация размеров последовательностей
* семантические ограничения: сортированная последовательность, отношение порядка
и т.д.
* Контейнеры, знающие о последовательностях
* Средства стандартной библиотеки C++14, отсутствующие в C++11
* Аналоги функциональности библиотек Boost.Range и Boost.Iterator
* Интеграция с Boost.Range и Boost.Iterator
* Аналоги алгоритмов стандартных библиотек других императивных языков (D, Java)
* Неизменяемые (чисто функциональные) структуры данных и алгоритмы для работы
с ними
* Параллельная реализация алгоритмов
* Выразить is_sorted_until через adjacent_find?
* преобразование строковых литералов в последовательности - проблема в ноле в
конце строки
* Возможно ли и целесообразно ли усилить категорию обхода до двусторонней
 последовательности?
* Синтаксический сахар: +seq <=> !!seq и/или seq.has_more() как в Java ?
* Операции для последовательностей вывода: seq << make_value() ?

Вспомогательные цели:
* трасировщики для операторов (например, для <) - модульные трассировщики
* functor_tracer - Подсчитывать число вызовов, завершивхися без исключений

--------------------------------------------------------------------------------
D.std.functional
+ аналог binaryReverseArgs = binary_reverse_args_functor
+ аналог not = not_fn
+ adjoin - объединение нескольких функций в одну, возвращающую кортеж
[2014-03-04-20.52]

* curry - аналог bind, закрепляющий первый аргумент функции
* compose, pipe - функции создания функциональных объектов compose_functor
* memoize - кэширующий функциональный объект
* toDelegate
--------------------------------------------------------------------------------
ОБОСНОВАНИЕ

Алгоритмы реализованы в виде двуслойной схемы. Первый слой взаимодействует с
пользователем и преобразует аргументы, переданные пользователем: контейнеры
в последовательности, указатели на функции-члены в функциональные объекты и т.д.
Второй слой не должен использоваться клиентами непосредственно, в нём считается,
что все аргументы преобразованы в готовую к использованию форму.

Такой подход выбран, чтобы избежать комбинаторного возрастания количества
алгоритмов. Можно было бы определить одну версию алгоритма для
последовательностей, а другую --- для контейнеров, но этот подход не
масшабируется: поддержка возможности передавать в качестве функциональных
объектов указатели на функции-члены потребует либо преобразования на стороне
клиента, либо удваивания количества алгоритмов.
*/
--------------------------------------------------------------------------------
