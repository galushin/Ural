/**
Ближайшие цели:

+ Аналоги средства из <numeric> стандартной библиотеки С++

* Аналоги средства из <iterator> стандартной библиотеки С++
* Аналоги средства из <functional> стандартной библиотеки С++
* Аналоги средства из <algorithm> стандартной библиотеки С++

* Полная документация

Дальнейшие цели:

* универсальный интерфейс для tuple, pair, complex, compressed_pair
* минимизация размеров последовательностей
* семантические ограничения: сортированная последовательность, отношение порядка
и т.д.
* Контейнеры, знающие о последовательностях
* Средства стандартной библиотеки C++14, отсутствующие в C++11
* Сопостовимое быстродействие со стандартной библиотекой (в частности, за счёт
специализированных алгоритмов copy)
* Аналоги функциональности библиотек Boost.Range и Boost.Iterator
* Интеграция с Boost.Range и Boost.Iterator
* Аналоги алгоритмов стандартных библиотек других императивных языков (D, Java)
* Неизменяемые (чисто функциональные) структуры данных и алгоритмы для работы
с ними
* Параллельная реализация алгоритмов
* Выразить is_sorted_until через adjacent_find?
* преобразование строковых литералов в последовательности - проблема в ноле в
конце строки

Вспомогательные цели:
* трасировщики для операторов (например, для <) - модульные трассировщики

ОБОСНОВАНИЕ

Алгоритмы реализованы в виде двуслойной схемы. Первый слой взаимодействует с
пользователем и преобразует аргументы, переданные пользователем: контейнеры
в последовательности, указатели на функции-члены в функциональные объекты и т.д.
Второй слой не должен использоваться клиентами непосредственно, в нём считается,
что все аргументы преобразованы в готовую к использованию форму.

Такой подход выбран, чтобы избежать комбинаторного возрастания количества
алгоритмов. Можно было бы определить одну версию алгоритма для
последовательностей, а другую --- для контейнеров, но этот подход не
масшабируется: поддержка возможности передавать в качестве функциональных
объектов указатели на функции-члены потребует либо преобразования на стороне
клиента, либо удваивания количества алгоритмов.
*/
