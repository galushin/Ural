/**
Нормативы и руководства

http://www.boost.org/community/exception_safety.html
http://www.boost.org/community/generic_programming.html
--------------------------------------------------------------------------------
Этапы:
1. STL функциональность
2. STL быстродействие
3. Статистический анализ
4. Последовательный статистический анализ
5. Численные методы
6. Аналитические методы

После того, как выполнены этапы 1 и 2, основной целью становится этап 3.
Остальные развиваются в той мере, в которой это требуется для реализации
процедур статистического анализа.
--------------------------------------------------------------------------------
Ближайшие цели (0.1):

+ Аналоги средства из <numeric> стандартной библиотеки С++
+ Выделить функцию copy_and_swap. В узком смысле это обобщённая реализация
присваивания (с сильной гарантией при исключениях).
+ Класс вероятности (с проверкой значения)

* "Математическое" распределения discrete_distribution

* Критерий согласия Пирсона
--------------------------------------------------------------------------------
0.9

* copy_and_swap в широком смысле - обобщённая функция, превращающая операцию
с базовой гарантией в аналогичную операцию с сильной гарантией.

* умные указатели с семантикой копирования (для объектов)

* Аналоги средства из <functional> стандартной библиотеки С++: greater_equal,
less_equal, bit_and, bit_or, bit_xor, специализации для указателей

* Аналоги средства из <iterator> стандартной библиотеки С++
* Аналоги средства из <algorithm> стандартной библиотеки С++, за исключением
алгоритмов, связанных со случайными числами

* for_each с двумя аргументами или zip-последовательности.
* возвращаемое значение rotate(s1, s2) и inplace_stable_partition
--------------------------------------------------------------------------------
1.0

[2014-03-03-14.19] Дискретное распределение по Уолкеру

* алгоритмы - (полиморфные)функциональные объекты. Это позволит, помимо прочего,
инкапсулировать вспомогательные функции, не предназначенные для
непосредственного использования клиентами.

* Учесть n2911
* Обобщённый класс-обёртка с проверяемым инвариантом
* Функциональные объекты: учесть is_transparent
http://www.open-std.org/JTC1/sc22/WG21/docs/papers/2013/n3657.html
* Согласование с http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n3908.html

* Последовательности на основе временных контейнеров
* Разобраться с иерархией категорий последовательностей. В частности, от чего
должен наследовать random_access_traversal_tag
* аналоги возможностей <algorithm>: shuffle и random_shuffle
* Определить, должен ли SinglePassSequence быть EqualityComparable
* Полная документация
--------------------------------------------------------------------------------
Дальнейшие цели:

+ Распаковка кортежа в список аргументов функции
+ Алгоритм вычисления значения многочлена [2014-03-05-07.49]

* Возможность "забрать" значение у аккумуляторов
* Класс многочлена (на основе вектора)
* Целые числа бесконечной точности (как упражнение - желательно)
* Дробно-рациональные функции
* векторы
* матрицы и тензоры
* алгебраические структуры

* Класс чисел с обнаружением переполнений
* Шаблон класса чисел с ограниченным (на этапе компиляции интервалом)
* Обёртка, накладывающая ограничения (задаётся предикатом) на базовый тип
* http://www.drdobbs.com/tools/value-range-propagation/229300211
* универсальный интерфейс для tuple, pair, complex, compressed_pair
* универсальный интерфейс для объектов, у которых может отсутствовать значение,
например - optional<T>, future<T> и т.д.
* Класс многочлена (на основе связного списка и одночленов)
* Интерполяционные многочлены (Ньютона и Лагранжа)
* Алгоритм(ы) ортогононализации
* Ортогональные многочлены

* concurent_queue на основе std::list<> и mutex. Вопрос в том, как это
тестировать

* усилить категорию обхода последовательностей, когда это возможно
* аналог boost::operators с поддержкой constexpr. boost::operators выражает
операторы через версии с присваиванием, это не совместимо с constexpr.

* минимизировать число явных циклов
* создание контейнеров на основе последовательности
* Аналоги remove и remove_if, если копирующие версии имеют большую сложность,
чем версии, работающие на месте.
* Сопостовимое быстродействие со стандартной библиотекой (в частности, за счёт
специализированных алгоритмов copy). Быстродействие должно сравниваться как по
количеству операций, так и по общим затратам времени.
* Оптимизация inplace_merge, equal_range, nth_element, rotate(s1, s2),
partition, stable_partition
* Поддержка разных компиляторов (Clang, VS)
* минимизация размеров последовательностей
* Контейнеры, знающие о последовательностях
* Средства стандартной библиотеки C++14, отсутствующие в C++11
* Аналоги функциональности библиотек Boost.Range и Boost.Iterator
* Интеграция с Boost.Range и Boost.Iterator
* Аналоги алгоритмов стандартных библиотек других императивных языков (D, Java)
* Выразить is_sorted_until через adjacent_find?
* преобразование строковых литералов в последовательности - проблема в ноле в
конце строки
* Возможно ли и целесообразно ли усилить категорию обхода до двусторонней
 последовательности в filter?
* Синтаксический сахар: +seq <=> !!seq и/или seq.has_more() как в Java ?
* Операции для последовательностей вывода: seq << make_value() ?

Вспомогательные цели:
* трасировщики для операторов (например, для <) - модульные трассировщики
* functor_tracer - Подсчитывать число вызовов, завершивхися без исключений

--------------------------------------------------------------------------------
Исследовательские проекты:
* семантические ограничения: сортированная последовательность, отношение порядка
и т.д.
* Неизменяемые (чисто функциональные) структуры данных и алгоритмы для работы
с ними. Алгоритмы и структуры данных Scala
* Параллельная реализация алгоритмов
* Последовательный статистический анализ в виде dll или программы, которая может
получать данные через порт ввода или интернет
* Мастер приложений для статистического анализа
* Последовательный статистический анализ
* последовательности (только) вывода: оператор <<
* уменьшить дублирование в алгоритмах. Например, heap_select и partial_sort
* базовый класс CRTP или другой способ, вводящий операторы сравнения по
определённому свойству. Полезно для классов-обёрток, инкапсулирующих одно
значение.
* Унифицировать arithmetic_progression и oudirected
--------------------------------------------------------------------------------
D.std.functional
+ аналог binaryReverseArgs = binary_reverse_args_functor
+ аналог not = not_fn
+ adjoin - объединение нескольких функций в одну, возвращающую кортеж
[2014-03-04-20.52]

* curry - аналог bind, закрепляющий первый аргумент функции
* compose, pipe - функции создания функциональных объектов compose_functor
* memoize - кэширующий функциональный объект
* toDelegate
*/
