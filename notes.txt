/**
Система компьюетерной алгебры и статистического анализа, встроенная в C++:
1. Библиотека аналитических, численных и статистических методов.
2. Интерпретируемый язык с тем же синтаксисом.
3. Графический интерфейс для этого языка.

Исследователь проводит анализ в интерактивном режиме, а затем полученную
программу копирует в исходный фал С++ и получает быструю независимую программу.

Для языка статистического анализа нужен, например, ввод данных из CSV, что
является аналогом функциональности std.csv язык программирования D.

Статистичеcкий анализ опирается на линейную алгебру, классические алгоритмы и
другие разделы высшей математики. Было бы разумно, чтобы пользователь имел такой
же доступ к базовой математической и алгоритмической функциональности как и сама
система статистического анализа.
*/

/**
Адаптор для указателей на функции-члены или функция вычисления значения функции
Первый вариант, на мой взгляд, лучше тем, что позволяет наследовать от всех
"потенциально функциональных объектов". С другой стороны, при наличии
boost::compressed_pair это может быть не так уж и важно.
*/

/**
Eric Niebler. Как отличить контейнер от интервала.

http://www.open-std.org/pipermail/ranges/2014-March/000474.html
I gave this some thought last night. I would define as_range as a
customization point. Folks overload it for their container types. The
general overload provided by a range library can evaluate the tests
below in order to distinguish ranges from containers

1) If the type being queried is a known range type provided by the range
library, it's a range. Return it.
2) If a trait is_range has been specialized, it's a range. Return it.
3) If the constness of T affects the constness of decltype(*begin(T{})),
it's a container. Return a pair of iterators.
4) Otherwise, it's an error
*/
