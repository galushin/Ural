/**
Система компьюетерной алгебры и статистического анализа, встроенная в C++:
1. Библиотека аналитических, численных и статистических методов.
2. Интерпретируемый язык с тем же синтаксисом.
3. Графический интерфейс для этого языка.

Исследователь проводит анализ в интерактивном режиме, а затем полученную
программу копирует в исходный фал С++ и получает быструю независимую программу.

Для языка статистического анализа нужен, например, ввод данных из CSV, что
является аналогом функциональности std.csv язык программирования D.

Статистичеcкий анализ опирается на линейную алгебру, классические алгоритмы и
другие разделы высшей математики. Было бы разумно, чтобы пользователь имел такой
же доступ к базовой математической и алгоритмической функциональности как и сама
система статистического анализа.
*/

/**
Адаптор для указателей на функции-члены или функция вычисления значения функции
Первый вариант, на мой взгляд, лучше тем, что позволяет наследовать от всех
"потенциально функциональных объектов". С другой стороны, при наличии
boost::compressed_pair это может быть не так уж и важно.
*/

/**
Eric Niebler. Как отличить контейнер от интервала.

http://www.open-std.org/pipermail/ranges/2014-March/000474.html
I gave this some thought last night. I would define as_range as a
customization point. Folks overload it for their container types. The
general overload provided by a range library can evaluate the tests
below in order to distinguish ranges from containers

1) If the type being queried is a known range type provided by the range
library, it's a range. Return it.
2) If a trait is_range has been specialized, it's a range. Return it.
3) If the constness of T affects the constness of decltype(*begin(T{})),
it's a container. Return a pair of iterators.
4) Otherwise, it's an error
*/

/** Eric Niebler: если алгоритм вызывается с временным контейнером, то
нужно вернуть специальную обёртку
*/

/**
get<> для кортежей не является constexpr функцией в случае, если элемент
представляет собой пустой класс
*/

/**
Список свойств математических распределений
boost_1_54_0/libs/math/doc/html/math_toolkit/dist_ref/nmp.html

Cumulative Distribution Function.
Complement of the Cumulative Distribution Function.
Cumulative Hazard Function.
Hazard Function.
kurtosis.
kurtosis_excess
mean.
median.
mode.
Probability Density Function.
range.
Quantile.
Quantile from the complement of the probability.
skewness.
standard deviation.
support.
variance.
*/

/** Если каждая последовательность или генератор случайных чисел кэширует
 результат, то при комбинировании кэши могут дублироваться
*/

/** Выбор между разными версиями одного алгоритма (_if, _bounded, _reversed)
и использованием адапторов сделан в пользу последнего, так как это позволяет
формировать алгоритмы, как предложения из отдельных слов.
*/

/** get(x, _1) возвращает x, если не определено иное
 для обёрток - специализировать
*/

/** xs | sorted | slice(0, 10) вызывает partial_sort
*/

/** expected<T> - значение или исключение, возникшее при его вычислении
По сути, это вариантный тип. Поэтому, есть смысл реализовать variant<Ts...>,
а затем выразить expected через variant<T, std::exception_ptr>.
В свою очередь, future/promise могут быть выражены как expected<T>, защищённый
мьютексом.
*/

/** Согласно этой точке зрения, noexcept нужно тольк для move-операций
So, in other words, the only convincing (for me) usage of noexcept is to declare
to function overload resolution mechanism your resolution of the trade-off
between run-time performance and exception safety guarantees.

http://akrzemi1.wordpress.com/2014/04/24/noexcept-what-for/
*/

/**
Функциональные объекты для математических функций

1. В специальном пространстве имён details импортируем функцию (из std), которая
 не может быть найдена с помощью ADL
2. В пространстве имён details создаём класс функционального объекта,
выполняющий неквалифицированный вызов, чтобы использовать ADL
3. В основное пространство имён импортируем созданный класс функциональных
объектов
4. Создаём функцию без аргументов с тем же именем, что "моделируемая" функция,
которая не получает параметров и возвращает нужный функциональный объект

Пример:
namespace ural
{
    namespace details
    {
        using std::abs;

        class abs_fn
        {
        public:
            template <class T>
            auto operator()(T const & x) const
            -> decltype(abs(x))
            {
                return abs(x);
            }
        };
    }

    using details::abs_fn;

    constexpr abs_fn abs()
    {
        return abs_fn{};
    }
}

ural::make_transform_sequence(xs, abs());

*/

/**
Что лучше одна функция, принимающая значение, или две функции: одна принимает
константную ссылку, а вторая --- ссылку на временный объект.

Одна из проблем: необходимость отдельной обработки случая, когда тип --- ссылка
*/

/** В С++11 контейнеры получили конструктор на основе списков инициализации.
Следующий логичный шаг: конструкторы на основе всего, к чему можно применить
begin и end
*/
